# 섹션 1 Spring Security Fundamentals

## 초기화 과정 이해

### SecurityBuilder / SecurityConfigurer

![](img/img.png)

- SecurityBuilder : 빌더 클래스로서 웹보안을 구성하는 **빈객체와 설정 클래스들을 생성**. WebSecurity와 HttpSecurity가 있음.
- SecurityConfigurer : Http요청과 관련된 보안처리 **필터들을 생성**하고 여러 **초기화 설정**에 관여함.
- -> SecurityBuilder는 SecurityConfigurer를 포함하고 있으며 인증 및 인가 초기화 작업은 SecurityConfigurer에 의해 진행됨.
  ![](img/img_1.png)
- SecurityBuilder를 구현한 WebSecurity : apply(SecurityConfigurer) -> 초기화 대상을 적용함
- WebSecurity : 먼저 초기화 작업에 관여함, -> FilterChainProxy 를 생성하여 반환
- HttpSecurity : 초기화 작접 진행 후 -> SecurityFilterChain를 생성하여 반환
- FilterChainProxy가 SecurityFilterChain에 의존 -> 사용자 요청 처리시 필터 체인을 실행

#### CustomSecurityConfigurer 만들기

- 먼저 시큐리티 필터체인 타입의 빈 생성하기

```java

@Configuration
public class SecurityConfig {
    /**
     * 시큐리티 필터체인 타입의 빈 생성하기
     * HttpSecurity.build()하여 SecurityFilterChain를 생성할 수 있다.
     */
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.authorizeRequests().anyRequest().authenticated();
        httpSecurity.formLogin();
        //SecurityFilterChain에 추가하기
        httpSecurity.apply(new CustomSecurityConfigurer().setFlag(false)); //apply를 통하여 SecurityConfigurer를 추가한다.
        return httpSecurity.build();

    }
}

public class CustomSecurityConfigurer extends AbstractHttpConfigurer<CustomSecurityConfigurer, HttpSecurity> {

    private boolean isSecure;

    @Override
    public void init(HttpSecurity builder) throws Exception {
        super.init(builder);
        System.out.println("CustomSecurityConfigurer.init");
    }

    @Override
    public void configure(HttpSecurity builder) throws Exception {
        super.configure(builder);
        System.out.println("CustomSecurityConfigurer.configure");
        if (isSecure) {
            System.out.println("https is required");
        } else {
            System.out.println("https is optional");
        }
    }

    // 체이닝 메서드를 위한 this 반환
    public CustomSecurityConfigurer setFlag(boolean isSecure) {
        this.isSecure = isSecure;
        return this;
    }
}
```

### 자동 설정에 의한 초기화 진행

![](img/img_3.png)

- 순서
- -> SpringWebMvcImportSelector
- -> SecurityFilterAutoConfiguration
- -> WebMvcSecurityConfiguration
- -> HttpSecurityConfiguration (중요) -> HttpSecurity 생성
- -> SpringBootWebSecurityConfiguration --> HttpSecurity 설정을 자동으로 하는 시큐리티 기본 설정 클래스
- -> WebSecurityConfiguration (중요) -> WebSecurity 생성
- -> WebSecurity -> 최종적으로 FilterChainProxy 생성됨

#### SpringWebMvcImportSelector

- 인터페이스 ImportSelector를 구현한 클래스
- -> 어떤 **조건에 따라서 설정 클래스를 로드**해야할 때 ImportSelector를 사용해서 로드할 수 있음.

#### SecurityFilterAutoConfiguration

- DelegatingFilterProxyRegistrationBean 빈을 생성 -> DelegatingFilterProxy를 등록
- -> DelegatingFilterProxy : "springSecurityFilterChain"이름의 빈을 검색해서 클라이언트의 요청을 빈에게 위임하는 클래스
- -> "springSecurityFilterChain"의 이름을 가진 빈이 FilterChainProxy라는 클래스임

#### WebMvcSecurityConfiguration

- ArgumentResolver 타입의 클래스를 생성함
- -> AuthenticationPrincipalArgumentResolver -> @AuthenticaionPrincipal 로 Principal 객체 바인딩
- -> CurrentSecurityContextArgumentResolver
- -> CsrfTokenArgumentResolver

#### HttpSecurityConfiguration

- HttpSecurity를 생성 (싱글톤이 아닌 프로토타입 빈) -> 생성할 때마다 각각의 빈이 생성됨
- ->  HttpSecurity : 공통 설정 클래스와 필터들을 생성하고, 최종적으로 SecurityFilterChain 빈 반환

#### SpringBootWebSecurityConfiguration

![](img/img_4.png)

- -> HttpSecurity 설정을 자동으로 하는 시큐리티 기본 설정 클래스
- -> HttpSecurityConfiguration에서 생성한 HttpSecurity 객체를 주입받는다.
- -> defaultSecurityFilterChain()을 호출하여 기본 설정으로 HttpSecurity build()를 호출하고 SecurityFilterChain 빈을 정의함

#### WebSecurityConfiguration

- WebSecurityConfiguration는 WebSecurity를 설정한다
- WebSecurity는 설정 클래스에서 정의한 SecurifyFilterChain 빈을 SecurityBuilder에 저장한다.
- WebSecurity가 build()를 실행하면 SecurityBuilder에서 SecurityFilterChain을 꺼내어 FilterChainProxy 생성자에게 전달한다.

### 커스텀 설정에 의한 초기화 과정

- 설정 클래스를 커스텀하게 생성하기 때문에 SpringBootWebSecurityConfiguration의 SecurityFilerChainConfiguration 클래스가 구동되지 않는다.
- 사용자 정의 설정 클래스 생성 시 SecurityFilterChain와 WebSecurityConfigurerAdapter 두가지 모두 설정할 수 없으며 하나만 정의해야함

### AuthenticationEntryPoint 이해

![](img/img_2.png)

- 인증에 실패했을 경우 후속작업에 대한 정의를 AuthenticationEntryPoint에서 할 수 있다.
- 시큐리티는 초기화 때 기본으로 두 개의 인증방식을 설정함 -> FormLoginConfigurer, HttpBasicConfigurer
- 각각의 인증 상황에서 인증 예외가 발생했을 때 시큐리티는 AuthenticationEntryPoint를 통해서 인증예외 이후에 어떻게 할 것인지 결정하게 하는 클래스
- **ExceptionHandlingConfigurer**에서 AuthenticationEntryPoint에 대한 설정을 진행
- **formLogin** 인증 시 : ExceptionHandlingConfigurer가 **LoginUrlAuthenticationEntryPoint**를 전달 받은 후
- -> defaultEntryPointMappings 맵에 저장
- **httpBasic** 인증 시 : ExceptionHandlingConfigurer가 **BasicAuthenticationEntryPoint**를 전달 받은 후
- -> defaultEntryPointMappings 맵에 저장
- **커스텀 인증** 시 : ExceptionHandlingConfigurer가 커스텀EntryPoint를 전달 받은 후
- -> defaultEntryPointMappings 맵에 저장 -> **커스텀 EntryPoint가 가장 우선**시 됨
- 커스텀 인증을 만들었으나 EntryPoint 없는 경우 -> Http403ForbiddenEntryPoint 가 저장됨
- **ExceptionTranslationFilter** : ExceptionHandlingConfigurer가 EntryPoint를 최종적으로 ExceptionTranslationFilter에 전달하여 저장함

## 시큐리티 기본

### 시큐리티 인증 및 인가 흐름 요약

![](img/img_5.png)

#### ServletFilter 부분

##### DelegatingFilterProxy

- 사용자가 요청을 시도 (인증이나 단순 접근 포함)
- -> 사용자 요청을 먼저 받는 곳은 스프링 컨테이너가 아닌 서블릿 컨테이너이기 때문에 프록시를 사용

##### FilterChainProxy

- 사용자 요청을 필터 처리

#### Authentication 부분
- 인증이 된 상태에선 해당 부분 건너뛴다.

##### AuthenticationFilter

- 일반적으로 UsernamePasswordAuthenticationFilter를 많이 사용
- -> Authentication 객체를 만드는 역할

##### AuthenticationManager

- AuthenticationFilter가 Authentication를 만들어 AuthenticationManager에 전달
- AuthenticationManager는 실제 인증처리할 수 있는 개체를 찾아서 위임하는 역할

##### AuthenticadtionProvider

- 실제 인증을 처리하는 객체
- 전달받은 Authentication을 이용하여 관련 정보 DB등 조회
- 주입된 UserDetailsService에 Id 존재여부 판단 후
- UserDetails 생성 이후 주입된 PasswordEncoder를 통해 패스워드 일치 여부도 확인
- -> 성공시 권한등을 포함한 UserDetails로 인증된 Authentication 객체를 생성해 리턴

##### UserDetailsSerivce

- UserDetails 존재여부 판단하는 서비스 클래스
- 일반적으로 Repository 주입받아 DB에 username에 해당하는 유저정보 질의 후 성공하면 UserDetails 객체 생성 전달
- cf)이곳에서는 username으로 존재 여부 확인만. 패스워드 비교는 AuthenticadtionProvider에서

##### SecurityContext
- 인증 성공 시 AuthenticationFilter가 SecurityContext Authentication객체를 저장함
- SecurityContext는 전역적으로 사용됨

#### Authorization 부분
- 요청이 스프링 컨테이너 자원에 접근 가능 여부를 검증함

##### ExceptionTranslationFilter
- 인증 또는 인가 예외가 발생했을 경우 해당 필터에서 처리를 함

##### FilterSecurityInterceptor
- 인가 여부 판단하는 필터
- AccessDecisionManager 의존
##### AccessDecisionManager
- 접근을 허가할 것인지 여부 최종 판단
- AccessDecisionVoter 의존
- AccessDecisionVoter의 처리 결과를 받아 판단함 
##### AccessDecisionVoter 
- 현재 사용자가 접근하고자하는 자원에 권한이 있는지 여부 체크하여 결과를 AccessDecisionManager에 전달


### HttpBasic 인증

- 기본 방식인 세션 쿠기방식의 UsernamePasswordAuthenticaionFilter 방식이 아닌 HttpBasic 사용
- HttpBasic는 base64 인코딩을 통해서 아이디와 패스워드를 전달하여 인증처리
- 인증 프로토콜은 HTTP 인증 헤더에 기술되어있음.
- 주의) 쉽게 디코딩 가능하므로 반드시 HTTPS와 같은 TLS기술과 함께 사용해야함.
#### 순서
- 클라이언트는 인증정보 없이 서버로 접속을 시도
- 서버는 클라이언트에 인증 요구를 보냄 
- -> 401 UnAuthorized 응답과 함께 헤더에 WWW-Authentication를 기술해서 realm(보안영역)과 Basic인증방법을 보냄
- 클라이언트가 서버로 접속할 때 Base64로 username과 password를 인코딩하고 Authorization 헤더에 보냄
- 성공하면 정상 상태 코드가 반환됨

#### HttpBasic 설정 클래스
##### HttpBasicConfigurer
- HttpBasic 인증에 대한 초기화, 속성에 대한 기본값 설정
- 기본 AuthenticationEntryPoint는 BasicAuthenticatinoEntryPoint이다 
- 필터는 BasicAuthenticationFilter를 사용한다.

##### BasicAuthenticationFilter
- HttpBasic 인증 시 기본 필터
- BasicAuthenticationConverter를 사용해서 요청헤더에 기술된 인증정보의 유효성을 체크하며 Base64 인코딩된 username과 password를 추출한다.
- 인증 과정에서 UsernamePasswordAuthenticationToken 생성하여 인증 시도 -> ProviderManager -> DaoAuthenticationProvider
- 인증 성공 시 Authentication이 SecurityContext에 저장됨
- 인증 실패 시 Basic인증을 통해 다시 인증하라는 메시지를 표시하는 BasicAuthenticationEntryPoint가 호출됨
- 인증 후 세션 사용 미사용 경우에 따라 처리 흐름에 차이 있음
- -> 세션 사용하면 요청마다 인증하지 않지만 사용안하면 요청마다 인증과정 거침
```java
@Configuration
public class SecurityConfig {
  @Bean
  SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
    httpSecurity.authorizeRequests().anyRequest().authenticated();
    httpSecurity.httpBasic() //HttpBasicConfigurer 설정
            .authenticationEntryPoint(new CustomAuthenticationEntryPoint()); //커스텀 EntryPoint설
    httpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.SATATELESS); // 설정하면 세션 없어져서 요청마다 인증 시도
    return httpSecurity.build();
  }
}
```
- 흐름
![](/img/img_6.png)
- 커스텀 엔트리 포인트
```java
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        // WWW-Authenticate 라는 규약을 지키지 않으면 브라우저는 Basic인증창을 띄우지 않음!
        response.addHeader("WWW-Authenticate", "Basic realm=localhost");
        response.sendError(HttpStatus.UNAUTHORIZED.value(), HttpStatus.UNAUTHORIZED.getReasonPhrase());
    }
}
```

### CORS 이해 (Cross Origin Resource Sharing, 교차 출처 리소스 공유)
- 웹 페이지가 자신의 출처가 아닌 다른 출처의 리소스에 접근할 때 브라우저는 별도의 통신 권한이 필요함 -> 시큐리티가 지원
- 웹 애플리케이션이 리소스가 자신의 출처와 다를 때 브라우저는 요청 헤더에 Origin 필드에 요청 출처를 함께 담아 교차 출처 HTTP 요청을 실행한다.
- 브라우저는 클라이언트의 요청헤더와 서버의 응답헤더를 비교해서 최종 응답을 결정함
- URL 구성요소 중 Protocol, Host, Post 세가지가 동일한지만 확인
#### CORS 요청의 종류 1 - Simple Request
- Simple Request는 예비요청(Preflight) 없이 서버에 요청을 한 후 서버가 응답헤더로 Access-Controll-Allow-Origin 과 같은 값을 전송하면 브라우저가 서로 비교 후 CORS정책 위반여부를 검사
- 요청 제약사항들이 있다.
#### CORS 요청의 종류 2 - Preflight Request
- 브라우저가 예비요청을 보내는 것은 Prefilght라고 하며 요청 메소드에는 OPTIONS가 사용됨
- SimpleRequest의 제약사항을 벗어난 경우 브라우저는 PrefilghtRequest를 보낸다.
- Prefilght를 보낼 때 Origin에 대한 정보와 Access-Controll-Request-Headers, Access-Control-Request-Method로 본요청에 대한 정보도 일부 포함하여 요청
- 서버가 보낸 응답헤더의 Access-Control-Allow_Origin:주소... 의 의미는 해당 url 이의로 요청할 경우 CORS 위반이라는 의미
#### 동일출처기준
- https://(스킴)security.io(호스트)(포트)
- -> 스킴, 호스트, 포트가 동일해야함 
- cf) 익스플로러는 포트를 무시함
#### CORS해결 - 서버에서 Access-Control-Allow-* 세팅
- Access-Control-Allow-Origin : 헤더에 작성된 출처만 허용
- Access-Control-Allow-Methods : preflight에 대한 응답으로 본요청에 사용할 수 있는 메서드를 나타냄
- Access-Control-Allow-Headers : preflight에 대한 응답으로 본요청에 사용할 수 있는 헤더 필드 이름을 나타냄
- Access-Control-Allow-Credential : 본요청에 쿠키나 인증등의 사용자 자격증명이 포함될 수 있음을 나타냄. Client의 credentials:include인 경우 true 필수
- Access-Control-Max-Age : prefight의 요청 결과를 캐시할 수 있는 시간을 나타내는 것으로 해당 기간 동안은 preflight를 하지 않게 된다.  

#### 스프링 시큐리티 - CORS
##### CorsConfigurer 
- SpringSecurity 필터 체인에 CorsFilter를 추가
- corsFilter라는 이름의 Bean이 제공되면 해당 CorsFilter 사용됨
- corsFilter라는 이름의 Bean이 없고 corsConfigurationSource 빈이 정의된 경우 해당 CorsConfiguration이 사용됨
- corsConfigurationSource빈이 정의되어 있지 않은 경우 Srping MVC가 클래스 경로에 있으면 HandlerMappingIntrospector가 사용됨 (시큐리티 없는 경우) 
##### CorsFilter
- CORS 예비요청을 하고 CORS 단순 및 본 요청을 가로채고, 제공된 CorsConfigurationSource를 통해 일치된 정책에 따라 
- -> CORS 응답헤더 와 같은 응답을 업데이트하기 위한 필터
- Spring MVC Java 구성과 Spring MVC XML 네임스페이스에서 CORS를 구성하는 대안이라 볼 수 있음(ex:CorsOrigin)
- 스프링웹에 의존하는 응용프로그램이나 javax.servlet에서 CORS 검사를 수행해야하는 보안 제약조건에 유용한 필터 