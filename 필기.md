# 섹션 1 Spring Security Fundamentals

## 초기화 과정 이해

### SecurityBuilder / SecurityConfigurer

![](img/img.png)

- SecurityBuilder : 빌더 클래스로서 웹보안을 구성하는 **빈객체와 설정 클래스들을 생성**. WebSecurity와 HttpSecurity가 있음.
- SecurityConfigurer : Http요청과 관련된 보안처리 **필터들을 생성**하고 여러 **초기화 설정**에 관여함.
- -> SecurityBuilder는 SecurityConfigurer를 포함하고 있으며 인증 및 인가 초기화 작업은 SecurityConfigurer에 의해 진행됨.
  ![](img/img_1.png)
- SecurityBuilder를 구현한 WebSecurity : apply(SecurityConfigurer) -> 초기화 대상을 적용함
- WebSecurity : 먼저 초기화 작업에 관여함, -> FilterChainProxy 를 생성하여 반환
- HttpSecurity : 초기화 작접 진행 후 -> SecurityFilterChain를 생성하여 반환
- FilterChainProxy가 SecurityFilterChain에 의존 -> 사용자 요청 처리시 필터 체인을 실행

#### CustomSecurityConfigurer 만들기

- 먼저 시큐리티 필터체인 타입의 빈 생성하기

```java

@Configuration
public class SecurityConfig {
    /**
     * 시큐리티 필터체인 타입의 빈 생성하기
     * HttpSecurity.build()하여 SecurityFilterChain를 생성할 수 있다.
     */
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.authorizeRequests().anyRequest().authenticated();
        httpSecurity.formLogin();
        //SecurityFilterChain에 추가하기
        httpSecurity.apply(new CustomSecurityConfigurer().setFlag(false)); //apply를 통하여 SecurityConfigurer를 추가한다.
        return httpSecurity.build();

    }
}

public class CustomSecurityConfigurer extends AbstractHttpConfigurer<CustomSecurityConfigurer, HttpSecurity> {

    private boolean isSecure;

    @Override
    public void init(HttpSecurity builder) throws Exception {
        super.init(builder);
        System.out.println("CustomSecurityConfigurer.init");
    }

    @Override
    public void configure(HttpSecurity builder) throws Exception {
        super.configure(builder);
        System.out.println("CustomSecurityConfigurer.configure");
        if (isSecure) {
            System.out.println("https is required");
        } else {
            System.out.println("https is optional");
        }
    }

    // 체이닝 메서드를 위한 this 반환
    public CustomSecurityConfigurer setFlag(boolean isSecure) {
        this.isSecure = isSecure;
        return this;
    }
}
```

### 자동 설정에 의한 초기화 진행

![](img/img_3.png)

- 순서
- -> SpringWebMvcImportSelector
- -> SecurityFilterAutoConfiguration
- -> WebMvcSecurityConfiguration
- -> HttpSecurityConfiguration (중요) -> HttpSecurity 생성
- -> SpringBootWebSecurityConfiguration --> HttpSecurity 설정을 자동으로 하는 시큐리티 기본 설정 클래스
- -> WebSecurityConfiguration (중요) -> WebSecurity 생성
- -> WebSecurity -> 최종적으로 FilterChainProxy 생성됨

#### SpringWebMvcImportSelector

- 인터페이스 ImportSelector를 구현한 클래스
- -> 어떤 **조건에 따라서 설정 클래스를 로드**해야할 때 ImportSelector를 사용해서 로드할 수 있음.

#### SecurityFilterAutoConfiguration

- DelegatingFilterProxyRegistrationBean 빈을 생성 -> DelegatingFilterProxy를 등록
- -> DelegatingFilterProxy : "springSecurityFilterChain"이름의 빈을 검색해서 클라이언트의 요청을 빈에게 위임하는 클래스
- -> "springSecurityFilterChain"의 이름을 가진 빈이 FilterChainProxy라는 클래스임

#### WebMvcSecurityConfiguration

- ArgumentResolver 타입의 클래스를 생성함
- -> AuthenticationPrincipalArgumentResolver -> @AuthenticaionPrincipal 로 Principal 객체 바인딩
- -> CurrentSecurityContextArgumentResolver
- -> CsrfTokenArgumentResolver

#### HttpSecurityConfiguration

- HttpSecurity를 생성 (싱글톤이 아닌 프로토타입 빈) -> 생성할 때마다 각각의 빈이 생성됨
- ->  HttpSecurity : 공통 설정 클래스와 필터들을 생성하고, 최종적으로 SecurityFilterChain 빈 반환

#### SpringBootWebSecurityConfiguration

![](img/img_4.png)

- -> HttpSecurity 설정을 자동으로 하는 시큐리티 기본 설정 클래스
- -> HttpSecurityConfiguration에서 생성한 HttpSecurity 객체를 주입받는다.
- -> defaultSecurityFilterChain()을 호출하여 기본 설정으로 HttpSecurity build()를 호출하고 SecurityFilterChain 빈을 정의함

#### WebSecurityConfiguration

- WebSecurityConfiguration는 WebSecurity를 설정한다
- WebSecurity는 설정 클래스에서 정의한 SecurifyFilterChain 빈을 SecurityBuilder에 저장한다.
- WebSecurity가 build()를 실행하면 SecurityBuilder에서 SecurityFilterChain을 꺼내어 FilterChainProxy 생성자에게 전달한다.

### 커스텀 설정에 의한 초기화 과정

- 설정 클래스를 커스텀하게 생성하기 때문에 SpringBootWebSecurityConfiguration의 SecurityFilerChainConfiguration 클래스가 구동되지 않는다.
- 사용자 정의 설정 클래스 생성 시 SecurityFilterChain와 WebSecurityConfigurerAdapter 두가지 모두 설정할 수 없으며 하나만 정의해야함

### AuthenticationEntryPoint 이해

![](img/img_2.png)

- 인증에 실패했을 경우 후속작업에 대한 정의를 AuthenticationEntryPoint에서 할 수 있다.
- 시큐리티는 초기화 때 기본으로 두 개의 인증방식을 설정함 -> FormLoginConfigurer, HttpBasicConfigurer
- 각각의 인증 상황에서 인증 예외가 발생했을 때 시큐리티는 AuthenticationEntryPoint를 통해서 인증예외 이후에 어떻게 할 것인지 결정하게 하는 클래스
- **ExceptionHandlingConfigurer**에서 AuthenticationEntryPoint에 대한 설정을 진행
- **formLogin** 인증 시 : ExceptionHandlingConfigurer가 **LoginUrlAuthenticationEntryPoint**를 전달 받은 후
- -> defaultEntryPointMappings 맵에 저장
- **httpBasic** 인증 시 : ExceptionHandlingConfigurer가 **BasicAuthenticationEntryPoint**를 전달 받은 후
- -> defaultEntryPointMappings 맵에 저장
- **커스텀 인증** 시 : ExceptionHandlingConfigurer가 커스텀EntryPoint를 전달 받은 후
- -> defaultEntryPointMappings 맵에 저장 -> **커스텀 EntryPoint가 가장 우선**시 됨
- 커스텀 인증을 만들었으나 EntryPoint 없는 경우 -> Http403ForbiddenEntryPoint 가 저장됨
- **ExceptionTranslationFilter** : ExceptionHandlingConfigurer가 EntryPoint를 최종적으로 ExceptionTranslationFilter에 전달하여 저장함

## 시큐리티 기본

### 시큐리티 인증 및 인가 흐름 요약

![](img/img_5.png)

#### ServletFilter 부분

##### DelegatingFilterProxy

- 사용자가 요청을 시도 (인증이나 단순 접근 포함)
- -> 사용자 요청을 먼저 받는 곳은 스프링 컨테이너가 아닌 서블릿 컨테이너이기 때문에 프록시를 사용

##### FilterChainProxy

- 사용자 요청을 필터 처리

#### Authentication 부분
- 인증이 된 상태에선 해당 부분 건너뛴다.

##### AuthenticationFilter

- 일반적으로 UsernamePasswordAuthenticationFilter를 많이 사용
- -> Authentication 객체를 만드는 역할

##### AuthenticationManager

- AuthenticationFilter가 Authentication를 만들어 AuthenticationManager에 전달
- AuthenticationManager는 실제 인증처리할 수 있는 개체를 찾아서 위임하는 역할

##### AuthenticadtionProvider

- 실제 인증을 처리하는 객체
- 전달받은 Authentication을 이용하여 관련 정보 DB등 조회
- 주입된 UserDetailsService에 Id 존재여부 판단 후
- UserDetails 생성 이후 주입된 PasswordEncoder를 통해 패스워드 일치 여부도 확인
- -> 성공시 권한등을 포함한 UserDetails로 인증된 Authentication 객체를 생성해 리턴

##### UserDetailsSerivce

- UserDetails 존재여부 판단하는 서비스 클래스
- 일반적으로 Repository 주입받아 DB에 username에 해당하는 유저정보 질의 후 성공하면 UserDetails 객체 생성 전달
- cf)이곳에서는 username으로 존재 여부 확인만. 패스워드 비교는 AuthenticadtionProvider에서

##### SecurityContext
- 인증 성공 시 AuthenticationFilter가 SecurityContext Authentication객체를 저장함
- SecurityContext는 전역적으로 사용됨

#### Authorization 부분
- 요청이 스프링 컨테이너 자원에 접근 가능 여부를 검증함

##### ExceptionTranslationFilter
- 인증 또는 인가 예외가 발생했을 경우 해당 필터에서 처리를 함

##### FilterSecurityInterceptor
- 인가 여부 판단하는 필터
- AccessDecisionManager 의존
##### AccessDecisionManager
- 접근을 허가할 것인지 여부 최종 판단
- AccessDecisionVoter 의존
- AccessDecisionVoter의 처리 결과를 받아 판단함 
##### AccessDecisionVoter 
- 현재 사용자가 접근하고자하는 자원에 권한이 있는지 여부 체크하여 결과를 AccessDecisionManager에 전달


### HttpBasic 인증

- 기본 방식인 세션 쿠기방식의 UsernamePasswordAuthenticaionFilter 방식이 아닌 HttpBasic 사용
- HttpBasic는 base64 인코딩을 통해서 아이디와 패스워드를 전달하여 인증처리
- 인증 프로토콜은 HTTP 인증 헤더에 기술되어있음.
- 주의) 쉽게 디코딩 가능하므로 반드시 HTTPS와 같은 TLS기술과 함께 사용해야함.
#### 순서
- 클라이언트는 인증정보 없이 서버로 접속을 시도
- 서버는 클라이언트에 인증 요구를 보냄 
- -> 401 UnAuthorized 응답과 함께 헤더에 WWW-Authentication를 기술해서 realm(보안영역)과 Basic인증방법을 보냄
- 클라이언트가 서버로 접속할 때 Base64로 username과 password를 인코딩하고 Authorization 헤더에 보냄
- 성공하면 정상 상태 코드가 반환됨

#### HttpBasic 설정 클래스
##### HttpBasicConfigurer
- HttpBasic 인증에 대한 초기화, 속성에 대한 기본값 설정
- 기본 AuthenticationEntryPoint는 BasicAuthenticatinoEntryPoint이다 
- 필터는 BasicAuthenticationFilter를 사용한다.

##### BasicAuthenticationFilter
- HttpBasic 인증 시 기본 필터
- BasicAuthenticationConverter를 사용해서 요청헤더에 기술된 인증정보의 유효성을 체크하며 Base64 인코딩된 username과 password를 추출한다.
- 인증 과정에서 UsernamePasswordAuthenticationToken 생성하여 인증 시도 -> ProviderManager -> DaoAuthenticationProvider
- 인증 성공 시 Authentication이 SecurityContext에 저장됨
- 인증 실패 시 Basic인증을 통해 다시 인증하라는 메시지를 표시하는 BasicAuthenticationEntryPoint가 호출됨
- 인증 후 세션 사용 미사용 경우에 따라 처리 흐름에 차이 있음
- -> 세션 사용하면 요청마다 인증하지 않지만 사용안하면 요청마다 인증과정 거침
```java
@Configuration
public class SecurityConfig {
  @Bean
  SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
    httpSecurity.authorizeRequests().anyRequest().authenticated();
    httpSecurity.httpBasic() //HttpBasicConfigurer 설정
            .authenticationEntryPoint(new CustomAuthenticationEntryPoint()); //커스텀 EntryPoint설
    httpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.SATATELESS); // 설정하면 세션 없어져서 요청마다 인증 시도
    return httpSecurity.build();
  }
}
```
- 흐름
![](/img/img_6.png)
- 커스텀 엔트리 포인트
```java
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        // WWW-Authenticate 라는 규약을 지키지 않으면 브라우저는 Basic인증창을 띄우지 않음!
        response.addHeader("WWW-Authenticate", "Basic realm=localhost");
        response.sendError(HttpStatus.UNAUTHORIZED.value(), HttpStatus.UNAUTHORIZED.getReasonPhrase());
    }
}
```

### Cors 이해
- 웹 페이지가 자신의 출처가 아닌 다른 출처의 리소스에 접근할 때 브라우저는 별도의 통신 권한이 필요함 -> 시큐리티가 지원
-  